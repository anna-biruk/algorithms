// Рекурсивный метод

const factorial = (n) => {
    if (n === 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
};

/*Реализуйте (с использованием рекурсивного процесса) функцию sequenceSum, которая находит сумму последовательности
 целых чисел. Последовательность задается двумя значениями: begin - начало последовательности, end -
 конец последовательности. Например: begin = 2 и end = 6 дают нам такую последовательность 2, 3, 4, 5, 6.
  Сумма такой последовательности будет: 20.
 */

const sequenceSum = (begin, end) => {

    if (begin > end) {
        return NaN;
    } else if (begin === end) {
        return begin;
    } else {
        return begin + sequenceSum(begin + 1, end);
    }

};
console.log(sequenceSum(2, 6)); //20

// Итеративный подсчет факториала

const factorial1 = (n) => {
    const iter = (counter, acc) => {
        if (counter === 1) {
            return acc;
        }
        return iter(counter - 1, counter * acc);
    };
    return iter(n, 1);
};
//Реализуйте тело функции smallestDivisor(), используя итеративный процесс.
// Функция должна находить наименьший делитель заданного числа. Число, передаваемое в функцию, больше нуля.
// Доп. условие: делитель должен быть больше единицы, за исключением случая, когда аргументом является единица
// (наименьшим делителем которой является также единица).
//Идея алгоритма:
//Попробуйте разделить число на 2.
//Если число делится без остатка, то это наименьший делитель.
//Если нет, то попробуйте следующий делитель.
//Если ничего не делит число без остатка, то переданное число является простым, так что его наименьший делитель
// — оно само (не считая 1)

const smallestDivisor = (num) => {
    const iter = (acc) => {
        if (acc > num / 2) {
            return num;
        } else if (num % acc === 0) {
            return acc;
        }
        return iter(acc + 1);
    };
    return iter(2);
};
smallestDivisor(15);

//Рекурсия — это когда что-то содержит себя в своём описании.
// Рекурсивный процесс — это процесс вычисления с отложенными вычислениями.
// Итеративный процесс — это процесс вычисления, когда состояние может быть описано фиксированным количеством значений.